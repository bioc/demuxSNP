---
title: "Demultiplexing_using_supervised_learning_with_cell_hashing_and_SNPs"
author:
  - name: Michael Lynch, University of Limerick
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
vignette: |
  %\VignetteIndexEntry{dim reduction with corral}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    message = FALSE,
    fig.width = 7.5
)
```




```{r }

library(SNPcheck)
library(ComplexHeatmap)
library(viridisLite)
library(Seurat)
library(ggpubr)
library(dittoSeq)
library(utils)
library(sessioninfo)
```

````{r}
colors <- structure(viridis(n = 3), names = c("-1", "0", "1"))
````

# Introduction

## Existing methods

This package is built on the premise of using SNP from commonly expressed genes to identify and reclassify uncalled or miscalled cells when demultiplexing scRNAseq data.
We also provide some helper function to optimise SNP selection, create training data for the classifier and merge SNP data into the SingleCellExperiment framework, while providing flexibility in selecting function parameters, training data and test data to the user.
@boggy_bff_2022

Demultiplexing in scRNAseq involves assigning cells back to their original sample, where cells from different donors, treatment types or physiological locations are sequenced together.

## Motivation

Here, we aim to leverage information from both modalities to optimise classification and minimise waste.
We note that as with other SNP based methods, performance is dependent on genetic differences between samples as well as sufficient sequencing depth.

Novel features:

* Uses both cell hashing and SNP data. 
Current methods are limited to using either the cell hashing counts or SNP calls.
By using both, improved performance is seen in classification, particularly when cell contributions are unevnely distributed.
* Selects SNPs based on gene expression to reduce noise and computational cost.
This reduces artifacts caused by cell-type and speeds things up.

We load three data objects. 
A SingleCellExperiment object containing RNA and HTO counts, a vcf file containing SNPs and a matrix containing SNP information for each cell (we will show you how to generate this SNPs matrix using VarTrix outside of R).

````{r}
data(sce,vcf,snps,package="SNPcheck")
````

## Installation

````{r eval=FALSE}

devtools::install_github("michaelplynch/SNPcheck", build_vignettes = TRUE)

browseVignettes(package="SNPcheck")

````


# Exploratory analysis

The HTO or LMO distribution is usually bimodal, with a signal (high counts) and background distribution (low counts) caused by non-specific binding.
Ideally, these distributions would be clearly separated with no overlap, but in practice, this is not always the  case.
in our example data, we see that the distributions all overlap to different extents for each Hashtag.

````{r echo=FALSE, warning=FALSE, fig.height=4,fig.width=7.5}
htos <- as.data.frame(t(as.matrix(log(counts(altExp(sce, "HTO"))))))

x1 <- gghistogram(htos, x = "Hashtag1", fill = dittoColors(1)[1], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)
x2 <- gghistogram(htos, x = "Hashtag2", fill = dittoColors(1)[2], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)
x3 <- gghistogram(htos, x = "Hashtag3", fill = dittoColors(1)[3], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)
x4 <- gghistogram(htos, x = "Hashtag4", fill = dittoColors(1)[4], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)
x5 <- gghistogram(htos, x = "Hashtag5", fill = dittoColors(1)[5], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)
x6 <- gghistogram(htos, x = "Hashtag6", fill = dittoColors(1)[6], palette = "lancet", xlim = c(0, 7), ylim = c(0, 1000), alpha = 1)

ggarrange(x1, x2, x3, x4, x5, x6, align = "hv", ncol = 3, nrow = 2)
````

As an example, we will run HTODemux on the data.

````{r}
seurat <- as.Seurat(sce,data=NULL)
seurat <- HTODemux(seurat)
seurat$hash.ID <- factor(as.character(seurat$hash.ID))
sce$seurat <- seurat$hash.ID

sce$seurat <- seurat$hash.ID
````

Here, we see an unusually large number of cells being called as "Negative".

Additionally, the library size of the "Negative" group looks similar to that of other groups.


````{r}
seurat$libsize <- colSums(GetAssayData(seurat,slot="counts",assay="RNA"))
dittoPlot(seurat, "libsize", group.by = "hash.ID")
````

For the remainder of this vignette we'll outline our method of checking whether or not cells have been called correctly and how to assign them to their appropriate group!

# Preprocessing

Common variants files, for example from the 1000 Genomes Project, can contain over 7 million SNPs.
To reduce computational cost and cell-type effects, we subset our SNPs list to those located within genes expressed across most cells in our data.

We first find the most commonly expressed genes in our RNA data, then subset the vcf file to SNPs seen in those genes.

````{r}
top_genes <- common_genes(sce = sce)

ensdb<-EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86
subset_vcf(vcf, top_genes = top_genes,ensdb)
````

Next, we wish to identify cells which we can confidently call to a particular group.
There are a number of ways this can be achieved, including probabilistic modelling of the HTO counts, manually setting non-conservative thresholds or using consensus calls. 
Here we have used demuxmix, a probabilistic model which we have set with a high acceptance threshold to generate training data (cells which we can confidently call as a particular singlet group).

````{r }
sce <- consensus_calls(sce)
````

# Variant Calling (VarTrix)

Variant calling is not done within the package. 
Instead, we refer the reader to VarTrix, where they can use the subsetted .vcf file along with their .bam, barcodes.tsv and reference genome to call SNPs.

A sample VarTrix command looks like the following:

````{bash eval=FALSE}

./vartrix -v <path_to_input_vcf> -b <path_to_cellranger_bam> -f <path_to_fasta_file> -c <path_to_cell_barcodes_file> -o <path_for_output_matrix>

````

Using the output matrix from Vartrix and the classifications from the HTO algorithm, we train a knn supervised learning algorithm.

# Cell reassignment, visualisation and evaluation

To keep things tidy, we will add the SNP data to our SingleCellExperiment object as an AlternativeExpreiment.
This function also filters out SNPs which are observed at a low frequency in the data.


````{r}

sce <- add_snps(sce, snps, thresh = 0.95)

altExp(sce, "SNP")

````

Before we reassign any cells, we will first visualise the results from individual algorithms.
Below, we compare Seurat and CiteFuse classification. 
Most of the uncertainty here lies between whether a cell is a Singlet/Doublet or Negative rather than which Hashtag.

Splitting the SNP data by Seurat classification, we initially see a large number of 'negative' cells which appear of good quality (high proportion of reads) which may be assignable to another hashtag.
This is consistent with the library size plot we visualised earlier.


````{r}
test <- Heatmap(counts(altExp(sce, "SNP")), 
                column_split = sce$seurat, 
                cluster_rows = FALSE, 
                show_column_names = FALSE, 
                cluster_column_slices = FALSE, 
                column_title_rot = -45, 
                row_title = "SNPs", 
                col = colors)

draw(test)
````

````{r}
````

````{r}
sce <- reassign(sce, k = 5)

table(sce$knn)
````


````{r}
test <- Heatmap(counts(altExp(sce, "SNP")),
                column_split = sce$knn, 
                cluster_rows = FALSE, 
                show_column_names = FALSE, 
                cluster_column_slices = FALSE, 
                column_names_rot = 45, 
                column_title_rot = -45, 
                row_title = "SNPs", 
                col = colors)

draw(test)
````

Focusing in on the new Hashtag5 group, we see that a lot of the Negative cells have now been reclassed to this group, as well as a small number of cells from other groups.

````{r}
test <- Heatmap(counts(altExp(sce, "SNP"))[, sce$knn == "Hashtag5"], 
                column_split = sce$seurat[sce$knn == "Hashtag5"], 
                cluster_rows = FALSE, 
                show_column_names = FALSE, 
                cluster_column_slices = FALSE, 
                column_names_rot = 45, 
                column_title_rot = -45, 
                row_title = "SNPs", 
                col = colors)

draw(test)
````

# Session Info

````{r}
sessionInfo()
````

# References
